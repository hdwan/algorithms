## 二分图

二分图通常针对 **无向图** 问题（有些题目虽然是有向图，但一样有二分图性质）。

在一张图中，如果能够**把全部的点分到两个集合**中，**保证两个集合内部没有任何边** ，**图中的边只存在于两个集合之间**，这张图就是**二分图**。

充要条件：图 G 中至少存在两个点，且图中所有回路的长度均为偶数。（因为存在奇数环的时候，环内必定会有两个相连的顶点颜色不同，不符合二分图条件）

**二分图不一定连通。**

### 染色法判定二分图

时间复杂度是 ``O(n+m)``, n 表示点数，m 表示边数

```c++
int n, m;
int h[N], e[M], ne[M], idx;
int color[N]; // 存储颜色 0表示未染色，1表示白色，2表示黑色

void add(int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}

// 返回true，可以划分；返回false，不能划分
// 参数：u表示当前节点，c表示当前点的颜色
bool dfs(int u, int c) {
    color[u] = c; // 将当前点染色，然后把所有与他相连的点(未染色的)染成另一种颜色(3 - c)
    for (int i = h[u]; ~i; i = ne[i]) {
        int tmp = e[i];
        if (!color[tmp]) {
            if (!dfs(tmp, 3 - c)) // 将相邻点染色，但是返回false，即无法划分
                return false;
        } else if (color[tmp] == c) // 相邻点已经染色并且颜色相同，不符合二分图定义，无法划分
            return false;
    }
    return true;
}
bool check() {
 bool flag = true;
    for (int i = 1; i <= n; i ++) { // 因为图不一定连通，所以需要遍历所有为染色的点并dfs
        if (!color[i]){
            if (!dfs(i, 1)) // 每一次dfs的时候，会把整个连通块都染色，所以后面再碰到未染色的图说明是不连通的，这时候默认染成同样的颜色(即1，这里每次dfs染色都是1这个yan's)
                flag = false;
        }
    }
}
```

### 二分图的最大匹配数

求出二分图的最大匹配数。注意：图需要满足二分图这个**前提**，才能使用**匈牙利算法**。

所谓 最大匹配数 的意思就是：

两个集合分别选一个点，这两个点之间有边就确认一段关系（一个集合中的两点**共同**占有另一集合中**同一个点**是不合法的(一夫一妻) ），最多的关系数量就是这张二分图的最大匹配。

循环每个点，判断它是否能找到对象，能则答案++

怎么判断？

​	遍历所有与它连接的点，如果某个点没被**自己**访问过 并且 没有对象或者它(某个点)对象能找到备胎(即能和其他点建立关系：之间	有边)，那么这个点就符合要求，能建立关系，更新match

```c++
int n1, n2, m; // n1为二分图左半边 n2为二分图右半边
int h[N], e[N], ne[N], idx;
int st[N], match[N];// st用于每个点去标记自己访问过的结点 match标记一个节点的匹配对象

bool find(int x)// x是否能找到对象
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
    return false;
}

//找能建立关系的点，选择二分图的左侧或者右侧 计数这一侧所有能建立关系的点的个数 得到的就是最终结果
int res = 0;
for (int i = 1; i <= max(n1, n2); i ++ )
{
    memset(st, 0, sizeof st);
    // st是针对某一个点的找对象过程 不是最短路中的针对全局， 因为这里的对象可以换，只要你有备胎  
    if (find(i)) res ++;
}

```