## KMP

**前缀和后缀**

前缀：不包含最后一个字母的所有子串。

后缀：不包含第一个字母的所有子串。

```c++
// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度  两个字符串从下标为1的地方开始存储
//先求s、p的长度，然后再在s、p前面插入空格 使其下标从1开始
s.insert(s.begin(), ' ');
p.insert(p.begin(), ' ');// c++写法

s = ' ' + s//python写法  针对str字符串型 
求模式串的Next数组：
for (int i = 2, j = 0; i <= m; i ++ ) // i从2开始 因为ne[1] = 0 没有前后缀
{
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ; // 当前字符前后缀匹配成功，j++
    ne[i] = j;
}

// 匹配过程
for (int i = 1, j = 0; i <= n; i ++ )
{
    while (j && s[i] != p[j + 1]) j = ne[j];
    // j为0 或者 当前匹配不符合的时候 从ne[j]处重新开始匹配
    if (s[i] == p[j + 1]) j ++ ; //当前i 和 j + 1相等，j++继续向后匹配(i每次会自动++)
    if (j == m)//已经匹配到了最后一位 成功匹配  
    {
        //j = ne[j];
        // 匹配成功后的逻辑
    }
}

```

